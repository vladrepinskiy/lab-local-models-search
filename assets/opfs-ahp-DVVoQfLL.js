import{c as e,d as t,i as n,l as r,o as i,r as a,s as o,u as s}from"./index-BBdSRlZ4.js";s();var c=`state.txt`,l=`data`,u={DIR:16384,FILE:32768},d,f,p,m,h,g,_,v,y,b,x,S,C,w,T,E,D,O,k,A,j=class extends a{constructor(e,{initialPoolSize:t=1e3,maintainedPoolSize:n=100,debug:r=!1}={}){super(e,{debug:r}),i(this,S),i(this,d),i(this,f),i(this,p),i(this,m),i(this,h),i(this,g,new Map),i(this,_,new Map),i(this,v,0),i(this,y,new Map),i(this,b,new Map),this.lastCheckpoint=0,this.checkpointInterval=1e3*60,this.poolCounter=0,i(this,x,new Set),this.initialPoolSize=t,this.maintainedPoolSize=n}async init(e,t){return await o(this,S,C).call(this),super.init(e,t)}async syncToFs(e=!1){await this.maybeCheckpointState(),await this.maintainPool(),e||this.flush()}async closeFs(){for(let e of r(this,_).values())e.close();r(this,h).flush(),r(this,h).close(),this.pg.Module.FS.quit()}async maintainPool(e){e||=this.maintainedPoolSize;let t=e-this.state.pool.length,n=[];for(let e=0;e<t;e++)n.push(new Promise(async e=>{++this.poolCounter;let t=`${(Date.now()-1704063600).toString(16).padStart(8,`0`)}-${this.poolCounter.toString(16).padStart(8,`0`)}`,n=await r(this,p).getFileHandle(t,{create:!0}),i=await n.createSyncAccessHandle();r(this,g).set(t,n),r(this,_).set(t,i),o(this,S,T).call(this,{opp:`createPoolFile`,args:[t]}),this.state.pool.push(t),e()}));for(let e=0;e>t;e--)n.push(new Promise(async e=>{let t=this.state.pool.pop();o(this,S,T).call(this,{opp:`deletePoolFile`,args:[t]});let n=r(this,g).get(t);r(this,_).get(t)?.close(),await r(this,p).removeEntry(n.name),r(this,g).delete(t),r(this,_).delete(t),e()}));await Promise.all(n)}_createPoolFileState(e){this.state.pool.push(e)}_deletePoolFileState(e){let t=this.state.pool.indexOf(e);t>-1&&this.state.pool.splice(t,1)}async maybeCheckpointState(){Date.now()-this.lastCheckpoint>this.checkpointInterval&&await this.checkpointState()}async checkpointState(){let e=new TextEncoder().encode(JSON.stringify(this.state));r(this,h).truncate(0),r(this,h).write(e,{at:0}),r(this,h).flush(),this.lastCheckpoint=Date.now()}flush(){for(let e of r(this,x))try{e.flush()}catch{}r(this,x).clear()}chmod(e,t){o(this,S,w).call(this,{opp:`chmod`,args:[e,t]},()=>{this._chmodState(e,t)})}_chmodState(e,t){let n=o(this,S,D).call(this,e);n.mode=t}close(e){let t=o(this,S,O).call(this,e);r(this,y).delete(e),r(this,b).delete(t)}fstat(e){let t=o(this,S,O).call(this,e);return this.lstat(t)}lstat(e){let t=o(this,S,D).call(this,e),n=t.type===`file`?r(this,_).get(t.backingFilename).getSize():0,i=4096;return{dev:0,ino:0,mode:t.mode,nlink:1,uid:0,gid:0,rdev:0,size:n,blksize:i,blocks:Math.ceil(n/i),atime:t.lastModified,mtime:t.lastModified,ctime:t.lastModified}}mkdir(e,t){o(this,S,w).call(this,{opp:`mkdir`,args:[e,t]},()=>{this._mkdirState(e,t)})}_mkdirState(e,t){let n=o(this,S,E).call(this,e),r=n.pop(),i=[],a=this.state.root;for(let r of n){if(i.push(e),!Object.prototype.hasOwnProperty.call(a.children,r))if(t?.recursive)this.mkdir(i.join(`/`));else throw new M(`ENOENT`,`No such file or directory`);if(a.children[r].type!==`directory`)throw new M(`ENOTDIR`,`Not a directory`);a=a.children[r]}if(Object.prototype.hasOwnProperty.call(a.children,r))throw new M(`EEXIST`,`File exists`);let s={type:`directory`,lastModified:Date.now(),mode:t?.mode||u.DIR,children:{}};a.children[r]=s}open(e,t,n){if(o(this,S,D).call(this,e).type!==`file`)throw new M(`EISDIR`,`Is a directory`);let i=o(this,S,k).call(this);return r(this,y).set(i,e),r(this,b).set(e,i),i}readdir(e){let t=o(this,S,D).call(this,e);if(t.type!==`directory`)throw new M(`ENOTDIR`,`Not a directory`);return Object.keys(t.children)}read(e,t,n,i,a){let s=o(this,S,O).call(this,e),c=o(this,S,D).call(this,s);if(c.type!==`file`)throw new M(`EISDIR`,`Is a directory`);return r(this,_).get(c.backingFilename).read(new Uint8Array(t.buffer,n,i),{at:a})}rename(e,t){o(this,S,w).call(this,{opp:`rename`,args:[e,t]},()=>{this._renameState(e,t,!0)})}_renameState(e,t,n=!1){let i=o(this,S,E).call(this,e),a=i.pop(),s=o(this,S,D).call(this,i.join(`/`));if(!Object.prototype.hasOwnProperty.call(s.children,a))throw new M(`ENOENT`,`No such file or directory`);let c=o(this,S,E).call(this,t),l=c.pop(),u=o(this,S,D).call(this,c.join(`/`));if(n&&Object.prototype.hasOwnProperty.call(u.children,l)){let e=u.children[l];r(this,_).get(e.backingFilename).truncate(0),this.state.pool.push(e.backingFilename)}u.children[l]=s.children[a],delete s.children[a]}rmdir(e){o(this,S,w).call(this,{opp:`rmdir`,args:[e]},()=>{this._rmdirState(e)})}_rmdirState(e){let t=o(this,S,E).call(this,e),n=t.pop(),r=o(this,S,D).call(this,t.join(`/`));if(!Object.prototype.hasOwnProperty.call(r.children,n))throw new M(`ENOENT`,`No such file or directory`);let i=r.children[n];if(i.type!==`directory`)throw new M(`ENOTDIR`,`Not a directory`);if(Object.keys(i.children).length>0)throw new M(`ENOTEMPTY`,`Directory not empty`);delete r.children[n]}truncate(e,t=0){let n=o(this,S,D).call(this,e);if(n.type!==`file`)throw new M(`EISDIR`,`Is a directory`);let i=r(this,_).get(n.backingFilename);if(!i)throw new M(`ENOENT`,`No such file or directory`);i.truncate(t),r(this,x).add(i)}unlink(e){o(this,S,w).call(this,{opp:`unlink`,args:[e]},()=>{this._unlinkState(e,!0)})}_unlinkState(e,t=!1){let n=o(this,S,E).call(this,e),i=n.pop(),a=o(this,S,D).call(this,n.join(`/`));if(!Object.prototype.hasOwnProperty.call(a.children,i))throw new M(`ENOENT`,`No such file or directory`);let s=a.children[i];if(s.type!==`file`)throw new M(`EISDIR`,`Is a directory`);if(delete a.children[i],t){let t=r(this,_).get(s.backingFilename);t?.truncate(0),r(this,x).add(t),r(this,b).has(e)&&(r(this,y).delete(r(this,b).get(e)),r(this,b).delete(e))}this.state.pool.push(s.backingFilename)}utimes(e,t,n){o(this,S,w).call(this,{opp:`utimes`,args:[e,t,n]},()=>{this._utimesState(e,t,n)})}_utimesState(e,t,n){let r=o(this,S,D).call(this,e);r.lastModified=n}writeFile(e,t,n){let i=o(this,S,E).call(this,e),a=i.pop(),s=o(this,S,D).call(this,i.join(`/`));if(Object.prototype.hasOwnProperty.call(s.children,a)){let t=s.children[a];t.lastModified=Date.now(),o(this,S,T).call(this,{opp:`setLastModified`,args:[e,t.lastModified]})}else{if(this.state.pool.length===0)throw Error(`No more file handles available in the pool`);let t={type:`file`,lastModified:Date.now(),mode:n?.mode||u.FILE,backingFilename:this.state.pool.pop()};s.children[a]=t,o(this,S,T).call(this,{opp:`createFileNode`,args:[e,t]})}let c=s.children[a],l=r(this,_).get(c.backingFilename);t.length>0&&(l.write(typeof t==`string`?new TextEncoder().encode(t):new Uint8Array(t),{at:0}),e.startsWith(`/pg_wal`)&&r(this,x).add(l))}_createFileNodeState(e,t){let n=o(this,S,E).call(this,e),r=n.pop(),i=o(this,S,D).call(this,n.join(`/`));i.children[r]=t;let a=this.state.pool.indexOf(t.backingFilename);return a>-1&&this.state.pool.splice(a,1),t}_setLastModifiedState(e,t){let n=o(this,S,D).call(this,e);n.lastModified=t}write(e,t,n,i,a){let s=o(this,S,O).call(this,e),c=o(this,S,D).call(this,s);if(c.type!==`file`)throw new M(`EISDIR`,`Is a directory`);let l=r(this,_).get(c.backingFilename);if(!l)throw new M(`EBADF`,`Bad file descriptor`);let u=l.write(new Uint8Array(t,n,i),{at:a});return s.startsWith(`/pg_wal`)&&r(this,x).add(l),u}};d=new WeakMap,f=new WeakMap,p=new WeakMap,m=new WeakMap,h=new WeakMap,g=new WeakMap,_=new WeakMap,v=new WeakMap,y=new WeakMap,b=new WeakMap,x=new WeakMap,S=new WeakSet,C=async function(){t(this,d,await navigator.storage.getDirectory()),t(this,f,await o(this,S,A).call(this,this.dataDir,{create:!0})),t(this,p,await o(this,S,A).call(this,l,{from:r(this,f),create:!0})),t(this,m,await r(this,f).getFileHandle(c,{create:!0})),t(this,h,await r(this,m).createSyncAccessHandle());let e=new ArrayBuffer(r(this,h).getSize());r(this,h).read(e,{at:0});let n,i=new TextDecoder().decode(e).split(`
`),a=!1;try{n=JSON.parse(i[0])}catch{n={root:{type:`directory`,lastModified:Date.now(),mode:u.DIR,children:{}},pool:[]},r(this,h).truncate(0),r(this,h).write(new TextEncoder().encode(JSON.stringify(n)),{at:0}),a=!0}this.state=n;let s=i.slice(1).filter(Boolean).map(e=>JSON.parse(e));for(let e of s){let t=`_${e.opp}State`;if(typeof this[t]==`function`)try{this[t].bind(this)(...e.args)}catch(t){console.warn(`Error applying OPFS AHP WAL entry`,e,t)}}let v=[],y=async e=>{if(e.type===`file`)try{let t=await r(this,p).getFileHandle(e.backingFilename),n=await t.createSyncAccessHandle();r(this,g).set(e.backingFilename,t),r(this,_).set(e.backingFilename,n)}catch(t){console.error(`Error opening file handle for node`,e,t)}else for(let t of Object.values(e.children))v.push(y(t))};await y(this.state.root);let b=[];for(let e of this.state.pool)b.push(new Promise(async t=>{r(this,g).has(e)&&console.warn(`File handle already exists for pool file`,e);let n=await r(this,p).getFileHandle(e),i=await n.createSyncAccessHandle();r(this,g).set(e,n),r(this,_).set(e,i),t()}));await Promise.all([...v,...b]),await this.maintainPool(a?this.initialPoolSize:this.maintainedPoolSize)},w=function(e,t){let n=o(this,S,T).call(this,e);try{t()}catch(e){throw r(this,h).truncate(n),e}},T=function(e){let t=JSON.stringify(e),n=new TextEncoder().encode(`
${t}`),i=r(this,h).getSize();return r(this,h).write(n,{at:i}),r(this,x).add(r(this,h)),i},E=function(e){return e.split(`/`).filter(Boolean)},D=function(e,t){let n=o(this,S,E).call(this,e),r=t||this.state.root;for(let e of n){if(r.type!==`directory`)throw new M(`ENOTDIR`,`Not a directory`);if(!Object.prototype.hasOwnProperty.call(r.children,e))throw new M(`ENOENT`,`No such file or directory`);r=r.children[e]}return r},O=function(e){let t=r(this,y).get(e);if(!t)throw new M(`EBADF`,`Bad file descriptor`);return t},k=function(){let t=++e(this,v)._;for(;r(this,y).has(t);)e(this,v)._++;return t},A=async function(e,t){let n=o(this,S,E).call(this,e),i=t?.from||r(this,d);for(let e of n)i=await i.getDirectoryHandle(e,{create:t?.create});return i};var M=class extends Error{constructor(e,t){super(t),typeof e==`number`?this.code=e:typeof e==`string`&&(this.code=n[e])}};export{j as OpfsAhpFS};