import{a as e,c as t,l as n,n as r,o as i,r as a,s as o,u as s}from"./index-Db7NFlvb.js";n();var c=`state.txt`,l=`data`,u={DIR:16384,FILE:32768},d,f,p,m,h,g,_,v,y,b,x,S,C,w,T,E,D,O,k,A,j=class extends r{constructor(t,{initialPoolSize:n=1e3,maintainedPoolSize:r=100,debug:i=!1}={}){super(t,{debug:i}),e(this,S),e(this,d),e(this,f),e(this,p),e(this,m),e(this,h),e(this,g,new Map),e(this,_,new Map),e(this,v,0),e(this,y,new Map),e(this,b,new Map),this.lastCheckpoint=0,this.checkpointInterval=1e3*60,this.poolCounter=0,e(this,x,new Set),this.initialPoolSize=n,this.maintainedPoolSize=r}async init(e,t){return await i(this,S,C).call(this),super.init(e,t)}async syncToFs(e=!1){await this.maybeCheckpointState(),await this.maintainPool(),e||this.flush()}async closeFs(){for(let e of t(this,_).values())e.close();t(this,h).flush(),t(this,h).close(),this.pg.Module.FS.quit()}async maintainPool(e){e||=this.maintainedPoolSize;let n=e-this.state.pool.length,r=[];for(let e=0;e<n;e++)r.push(new Promise(async e=>{++this.poolCounter;let n=`${(Date.now()-1704063600).toString(16).padStart(8,`0`)}-${this.poolCounter.toString(16).padStart(8,`0`)}`,r=await t(this,p).getFileHandle(n,{create:!0}),a=await r.createSyncAccessHandle();t(this,g).set(n,r),t(this,_).set(n,a),i(this,S,T).call(this,{opp:`createPoolFile`,args:[n]}),this.state.pool.push(n),e()}));for(let e=0;e>n;e--)r.push(new Promise(async e=>{let n=this.state.pool.pop();i(this,S,T).call(this,{opp:`deletePoolFile`,args:[n]});let r=t(this,g).get(n);t(this,_).get(n)?.close(),await t(this,p).removeEntry(r.name),t(this,g).delete(n),t(this,_).delete(n),e()}));await Promise.all(r)}_createPoolFileState(e){this.state.pool.push(e)}_deletePoolFileState(e){let t=this.state.pool.indexOf(e);t>-1&&this.state.pool.splice(t,1)}async maybeCheckpointState(){Date.now()-this.lastCheckpoint>this.checkpointInterval&&await this.checkpointState()}async checkpointState(){let e=new TextEncoder().encode(JSON.stringify(this.state));t(this,h).truncate(0),t(this,h).write(e,{at:0}),t(this,h).flush(),this.lastCheckpoint=Date.now()}flush(){for(let e of t(this,x))try{e.flush()}catch{}t(this,x).clear()}chmod(e,t){i(this,S,w).call(this,{opp:`chmod`,args:[e,t]},()=>{this._chmodState(e,t)})}_chmodState(e,t){let n=i(this,S,D).call(this,e);n.mode=t}close(e){let n=i(this,S,O).call(this,e);t(this,y).delete(e),t(this,b).delete(n)}fstat(e){let t=i(this,S,O).call(this,e);return this.lstat(t)}lstat(e){let n=i(this,S,D).call(this,e),r=n.type===`file`?t(this,_).get(n.backingFilename).getSize():0,a=4096;return{dev:0,ino:0,mode:n.mode,nlink:1,uid:0,gid:0,rdev:0,size:r,blksize:a,blocks:Math.ceil(r/a),atime:n.lastModified,mtime:n.lastModified,ctime:n.lastModified}}mkdir(e,t){i(this,S,w).call(this,{opp:`mkdir`,args:[e,t]},()=>{this._mkdirState(e,t)})}_mkdirState(e,t){let n=i(this,S,E).call(this,e),r=n.pop(),a=[],o=this.state.root;for(let r of n){if(a.push(e),!Object.prototype.hasOwnProperty.call(o.children,r))if(t?.recursive)this.mkdir(a.join(`/`));else throw new M(`ENOENT`,`No such file or directory`);if(o.children[r].type!==`directory`)throw new M(`ENOTDIR`,`Not a directory`);o=o.children[r]}if(Object.prototype.hasOwnProperty.call(o.children,r))throw new M(`EEXIST`,`File exists`);let s={type:`directory`,lastModified:Date.now(),mode:t?.mode||u.DIR,children:{}};o.children[r]=s}open(e,n,r){if(i(this,S,D).call(this,e).type!==`file`)throw new M(`EISDIR`,`Is a directory`);let a=i(this,S,k).call(this);return t(this,y).set(a,e),t(this,b).set(e,a),a}readdir(e){let t=i(this,S,D).call(this,e);if(t.type!==`directory`)throw new M(`ENOTDIR`,`Not a directory`);return Object.keys(t.children)}read(e,n,r,a,o){let s=i(this,S,O).call(this,e),c=i(this,S,D).call(this,s);if(c.type!==`file`)throw new M(`EISDIR`,`Is a directory`);return t(this,_).get(c.backingFilename).read(new Uint8Array(n.buffer,r,a),{at:o})}rename(e,t){i(this,S,w).call(this,{opp:`rename`,args:[e,t]},()=>{this._renameState(e,t,!0)})}_renameState(e,n,r=!1){let a=i(this,S,E).call(this,e),o=a.pop(),s=i(this,S,D).call(this,a.join(`/`));if(!Object.prototype.hasOwnProperty.call(s.children,o))throw new M(`ENOENT`,`No such file or directory`);let c=i(this,S,E).call(this,n),l=c.pop(),u=i(this,S,D).call(this,c.join(`/`));if(r&&Object.prototype.hasOwnProperty.call(u.children,l)){let e=u.children[l];t(this,_).get(e.backingFilename).truncate(0),this.state.pool.push(e.backingFilename)}u.children[l]=s.children[o],delete s.children[o]}rmdir(e){i(this,S,w).call(this,{opp:`rmdir`,args:[e]},()=>{this._rmdirState(e)})}_rmdirState(e){let t=i(this,S,E).call(this,e),n=t.pop(),r=i(this,S,D).call(this,t.join(`/`));if(!Object.prototype.hasOwnProperty.call(r.children,n))throw new M(`ENOENT`,`No such file or directory`);let a=r.children[n];if(a.type!==`directory`)throw new M(`ENOTDIR`,`Not a directory`);if(Object.keys(a.children).length>0)throw new M(`ENOTEMPTY`,`Directory not empty`);delete r.children[n]}truncate(e,n=0){let r=i(this,S,D).call(this,e);if(r.type!==`file`)throw new M(`EISDIR`,`Is a directory`);let a=t(this,_).get(r.backingFilename);if(!a)throw new M(`ENOENT`,`No such file or directory`);a.truncate(n),t(this,x).add(a)}unlink(e){i(this,S,w).call(this,{opp:`unlink`,args:[e]},()=>{this._unlinkState(e,!0)})}_unlinkState(e,n=!1){let r=i(this,S,E).call(this,e),a=r.pop(),o=i(this,S,D).call(this,r.join(`/`));if(!Object.prototype.hasOwnProperty.call(o.children,a))throw new M(`ENOENT`,`No such file or directory`);let s=o.children[a];if(s.type!==`file`)throw new M(`EISDIR`,`Is a directory`);if(delete o.children[a],n){let n=t(this,_).get(s.backingFilename);n?.truncate(0),t(this,x).add(n),t(this,b).has(e)&&(t(this,y).delete(t(this,b).get(e)),t(this,b).delete(e))}this.state.pool.push(s.backingFilename)}utimes(e,t,n){i(this,S,w).call(this,{opp:`utimes`,args:[e,t,n]},()=>{this._utimesState(e,t,n)})}_utimesState(e,t,n){let r=i(this,S,D).call(this,e);r.lastModified=n}writeFile(e,n,r){let a=i(this,S,E).call(this,e),o=a.pop(),s=i(this,S,D).call(this,a.join(`/`));if(Object.prototype.hasOwnProperty.call(s.children,o)){let t=s.children[o];t.lastModified=Date.now(),i(this,S,T).call(this,{opp:`setLastModified`,args:[e,t.lastModified]})}else{if(this.state.pool.length===0)throw Error(`No more file handles available in the pool`);let t={type:`file`,lastModified:Date.now(),mode:r?.mode||u.FILE,backingFilename:this.state.pool.pop()};s.children[o]=t,i(this,S,T).call(this,{opp:`createFileNode`,args:[e,t]})}let c=s.children[o],l=t(this,_).get(c.backingFilename);n.length>0&&(l.write(typeof n==`string`?new TextEncoder().encode(n):new Uint8Array(n),{at:0}),e.startsWith(`/pg_wal`)&&t(this,x).add(l))}_createFileNodeState(e,t){let n=i(this,S,E).call(this,e),r=n.pop(),a=i(this,S,D).call(this,n.join(`/`));a.children[r]=t;let o=this.state.pool.indexOf(t.backingFilename);return o>-1&&this.state.pool.splice(o,1),t}_setLastModifiedState(e,t){let n=i(this,S,D).call(this,e);n.lastModified=t}write(e,n,r,a,o){let s=i(this,S,O).call(this,e),c=i(this,S,D).call(this,s);if(c.type!==`file`)throw new M(`EISDIR`,`Is a directory`);let l=t(this,_).get(c.backingFilename);if(!l)throw new M(`EBADF`,`Bad file descriptor`);let u=l.write(new Uint8Array(n,r,a),{at:o});return s.startsWith(`/pg_wal`)&&t(this,x).add(l),u}};d=new WeakMap,f=new WeakMap,p=new WeakMap,m=new WeakMap,h=new WeakMap,g=new WeakMap,_=new WeakMap,v=new WeakMap,y=new WeakMap,b=new WeakMap,x=new WeakMap,S=new WeakSet,C=async function(){s(this,d,await navigator.storage.getDirectory()),s(this,f,await i(this,S,A).call(this,this.dataDir,{create:!0})),s(this,p,await i(this,S,A).call(this,l,{from:t(this,f),create:!0})),s(this,m,await t(this,f).getFileHandle(c,{create:!0})),s(this,h,await t(this,m).createSyncAccessHandle());let e=new ArrayBuffer(t(this,h).getSize());t(this,h).read(e,{at:0});let n,r=new TextDecoder().decode(e).split(`
`),a=!1;try{n=JSON.parse(r[0])}catch{n={root:{type:`directory`,lastModified:Date.now(),mode:u.DIR,children:{}},pool:[]},t(this,h).truncate(0),t(this,h).write(new TextEncoder().encode(JSON.stringify(n)),{at:0}),a=!0}this.state=n;let o=r.slice(1).filter(Boolean).map(e=>JSON.parse(e));for(let e of o){let t=`_${e.opp}State`;if(typeof this[t]==`function`)try{this[t].bind(this)(...e.args)}catch(t){console.warn(`Error applying OPFS AHP WAL entry`,e,t)}}let v=[],y=async e=>{if(e.type===`file`)try{let n=await t(this,p).getFileHandle(e.backingFilename),r=await n.createSyncAccessHandle();t(this,g).set(e.backingFilename,n),t(this,_).set(e.backingFilename,r)}catch(t){console.error(`Error opening file handle for node`,e,t)}else for(let t of Object.values(e.children))v.push(y(t))};await y(this.state.root);let b=[];for(let e of this.state.pool)b.push(new Promise(async n=>{t(this,g).has(e)&&console.warn(`File handle already exists for pool file`,e);let r=await t(this,p).getFileHandle(e),i=await r.createSyncAccessHandle();t(this,g).set(e,r),t(this,_).set(e,i),n()}));await Promise.all([...v,...b]),await this.maintainPool(a?this.initialPoolSize:this.maintainedPoolSize)},w=function(e,n){let r=i(this,S,T).call(this,e);try{n()}catch(e){throw t(this,h).truncate(r),e}},T=function(e){let n=JSON.stringify(e),r=new TextEncoder().encode(`
${n}`),i=t(this,h).getSize();return t(this,h).write(r,{at:i}),t(this,x).add(t(this,h)),i},E=function(e){return e.split(`/`).filter(Boolean)},D=function(e,t){let n=i(this,S,E).call(this,e),r=t||this.state.root;for(let e of n){if(r.type!==`directory`)throw new M(`ENOTDIR`,`Not a directory`);if(!Object.prototype.hasOwnProperty.call(r.children,e))throw new M(`ENOENT`,`No such file or directory`);r=r.children[e]}return r},O=function(e){let n=t(this,y).get(e);if(!n)throw new M(`EBADF`,`Bad file descriptor`);return n},k=function(){let e=++o(this,v)._;for(;t(this,y).has(e);)o(this,v)._++;return e},A=async function(e,n){let r=i(this,S,E).call(this,e),a=n?.from||t(this,d);for(let e of r)a=await a.getDirectoryHandle(e,{create:n?.create});return a};var M=class extends Error{constructor(e,t){super(t),typeof e==`number`?this.code=e:typeof e==`string`&&(this.code=a[e])}};export{j as OpfsAhpFS};